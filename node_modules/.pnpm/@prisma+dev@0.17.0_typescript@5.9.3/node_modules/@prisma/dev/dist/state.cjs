"use strict";var ye=Object.create;var O=Object.defineProperty;var ve=Object.getOwnPropertyDescriptor;var we=Object.getOwnPropertyNames;var Se=Object.getPrototypeOf,De=Object.prototype.hasOwnProperty;var xe=(t,e)=>{for(var r in e)O(t,r,{get:e[r],enumerable:!0})},z=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of we(e))!De.call(t,s)&&s!==r&&O(t,s,{get:()=>e[s],enumerable:!(n=ve(e,s))||n.enumerable});return t};var D=(t,e,r)=>(r=t!=null?ye(Se(t)):{},z(e||!t||!t.__esModule?O(r,"default",{value:t,enumerable:!0}):r,t)),ke=t=>z(O({},"__esModule",{value:!0}),t);var Be={};xe(Be,{ServerAlreadyRunningError:()=>j,ServerState:()=>h,ServerStateAlreadyExistsError:()=>R,deleteServer:()=>Ie,getServerStatus:()=>X,isServerRunning:()=>me,killServer:()=>Pe});module.exports=ke(Be);var he=require("fs/promises"),g=require("pathe"),w=require("proper-lockfile"),J=require("std-env"),a=require("valibot");var Y=require("fs"),l=require("fs/promises"),Z=require("util"),Q=require("zlib");var d=D(require("path"),1),I=D(require("os"),1),$=D(require("process"),1),m=I.default.homedir(),B=I.default.tmpdir(),{env:y}=$.default,Oe=t=>{let e=d.default.join(m,"Library");return{data:d.default.join(e,"Application Support",t),config:d.default.join(e,"Preferences",t),cache:d.default.join(e,"Caches",t),log:d.default.join(e,"Logs",t),temp:d.default.join(B,t)}},$e=t=>{let e=y.APPDATA||d.default.join(m,"AppData","Roaming"),r=y.LOCALAPPDATA||d.default.join(m,"AppData","Local");return{data:d.default.join(r,t,"Data"),config:d.default.join(e,t,"Config"),cache:d.default.join(r,t,"Cache"),log:d.default.join(r,t,"Log"),temp:d.default.join(B,t)}},_e=t=>{let e=d.default.basename(m);return{data:d.default.join(y.XDG_DATA_HOME||d.default.join(m,".local","share"),t),config:d.default.join(y.XDG_CONFIG_HOME||d.default.join(m,".config"),t),cache:d.default.join(y.XDG_CACHE_HOME||d.default.join(m,".cache"),t),log:d.default.join(y.XDG_STATE_HOME||d.default.join(m,".local","state"),t),temp:d.default.join(B,e,t)}};function N(t,{suffix:e="nodejs"}={}){if(typeof t!="string")throw new TypeError(`Expected a string, got ${typeof t}`);return e&&(t+=`-${e}`),$.default.platform==="darwin"?Oe(t):$.default.platform==="win32"?$e(t):_e(t)}var ee=D(require("zeptomatch"),1),Te=N("prisma-dev"),Fe=(0,Z.promisify)(Q.unzip);function v(t){return`${Te.data}/${t}`}function te(t){return t!=null&&typeof t=="object"&&"code"in t&&t.code==="ENOENT"}async function re(t){try{return await(0,l.readFile)(t,{encoding:"utf-8"})}catch(e){if(te(e))return null;throw e}}async function se(t){await(0,l.mkdir)(t,{recursive:!0})}async function oe(t,e){try{return(await(0,l.readdir)(t,{withFileTypes:!0})).reduce((n,s)=>(s.isDirectory()&&!s.name.startsWith(".")&&(!e||(0,ee.default)(e,s.name))&&n.push(s.name),n),[])}catch(r){if(te(r))return[];throw r}}async function ae(t){await(0,l.rm)(t,{force:!0,recursive:!0})}var ne=require("timers/promises"),x=require("std-env");function U(t,e){if(t==null)return!1;try{return x.process.kill?.(t,0)??!0}catch(r){return e&&console.error(`Error checking if process with PID ${t} exists:`,r),!1}}async function ie(t,e){if(!x.process.kill)return!1;try{x.process.kill(t,"SIGTERM")}catch(n){return e&&console.error(`Error killing process with PID ${t}:`,n),!1}let r=0;do{if(!U(t,e))return!0;await(0,ne.setTimeout)(100)}while(++r<50);try{return x.process.kill(t,"SIGKILL")}catch(n){return e&&console.error(`Error forcefully killing process with PID ${t}:`,n),!1}}var b=require("get-port-please"),A=require("remeda"),ce=51214,ue=51213,de=51215,T=65535,P=-1/0;async function F(t){let{debug:e,name:r,requestedPorts:n,servers:s}=t,{portsUsedByOtherServers:o,portsUsedByThisServerLastTime:i}=Re(r,s);e&&(console.debug(`ports used by other servers: ${Object.keys(o).join(", ")}`),console.debug(`ports used by "${r}" server last time: ${JSON.stringify(i)}`));let c={databasePort:P,port:P,shadowDatabasePort:P},u=["port","databasePort","shadowDatabasePort"];for(let p of u){let f=await Ee({debug:e,portKey:p,portsUsedByOtherServers:o,portsUsedByThisServerLastTime:i,requestedPorts:n})??await Ae({debug:e,pickedPorts:c,portKey:p,portsUsedByOtherServers:o,portsUsedByThisServerLastTime:i});e&&console.debug(`Got port for "${p}": ${f}`),c[p]=f}return e&&console.debug(`Picked ports: ${JSON.stringify(c)}`),c}async function Ee(t){let{debug:e,portKey:r,portsUsedByOtherServers:n,portsUsedByThisServerLastTime:s,requestedPorts:o}=t,{[r]:i,...c}=o;if(pe(i))return await je({debug:e,otherRequestedPorts:c,portKey:r,portsUsedByOtherServers:n,requestedPort:i}),i;let u=s?.[r]??P;if(!pe(u))return e&&console.debug(`No port specified for "${r}". Trying to pick a new port.`),null;let p=u in n;return p||Object.values(c).includes(u)?(e&&console.debug(`Port ${u} that was used last time for this server, ${p?"is also used by another server":"has been requested for another service"}. Trying to pick a new port.`),null):await(0,b.checkPort)(u)===!1?(e&&console.debug(`Port ${u}, that was used last time for this server, is not available. Trying to pick a new port.`),null):(e&&console.debug(`Using port ${u} for "${r}" as it was used last time and is available.`),u)}async function Ae(t){let{debug:e,pickedPorts:r,portKey:n,portsUsedByOtherServers:s,portsUsedByThisServerLastTime:o}=t,i=Math.max(ce,ue,de)+1,c=[...Object.values(r),...Object.keys(s).map(Number),...Object.values(o||{})],u=Math.min(Math.max(i,...c)+100,T),p=(0,A.difference)((0,A.range)(i,u),c),f={port:ue,databasePort:ce,shadowDatabasePort:de}[n];try{return await(0,b.getPort)({port:f in s||Object.values(r).includes(f)||Object.values(o||{}).includes(f)?void 0:f,ports:p})}catch(S){if(S instanceof Error&&S.name==="GetPortError"&&u+1<=T)return e&&console.debug(`Expanding port lookup to range [${u+1}, ${T}].`),await(0,b.getPort)({portRange:[u+1,T]});throw S}}function pe(t){return t>=0}function Re(t,e){let r={},n;for(let s of e){let{databasePort:o,port:i,shadowDatabasePort:c}=s;if(s.name===t){n={databasePort:o,port:i,shadowDatabasePort:c};continue}r[o]=!0,r[i]=!0,r[c]=!0}return{portsUsedByOtherServers:r,portsUsedByThisServerLastTime:n}}async function je(t){let{debug:e,otherRequestedPorts:r,portKey:n,portsUsedByOtherServers:s,requestedPort:o}=t;if(o in s)throw e&&console.error(`Port ${o} was requested for "${n}", but is already used by another server.`),new q(o);if(Object.values(r).includes(o))throw e&&console.error(`Port ${o} was requested for "${n}", but also for another key.`),new V(o);if((0,b.isUnsafePort)(o))throw e&&console.error(`Port ${o} was requested for "${n}", but is unsafe.`),new E(o);if(await(0,b.checkPort)(o)===!1)throw e&&console.error(`Port ${o} was requested for "${n}", but is not available.`),new E(o)}var E=class extends Error{constructor(r){super(`Port \`${r}\` is not available.`);this.port=r}name="PortNotAvailableError"},V=class extends Error{constructor(r){super(`Port number \`${r}\` was requested twice. Please choose a different port for each service.`);this.port=r}name="PortRequestedTwiceError"},q=class extends Error{constructor(r){super(`Port number \`${r}\` belongs to another Prisma Dev server. Please choose a different port.`);this.port=r}name="PortBelongsToAnotherServerError"};var G=(0,a.pipe)((0,a.string)(),(0,a.url)()),le=(0,a.object)({connectionString:G,prismaORMConnectionString:(0,a.optional)(G),terminalCommand:(0,a.optional)((0,a.string)())}),fe=(0,a.object)({url:G}),C=(0,a.pipe)((0,a.number)(),(0,a.integer)(),(0,a.minValue)(1)),Me=(0,a.object)({database:le,http:fe,ppg:fe,shadowDatabase:le}),Le=(0,a.object)({databasePort:C,exports:(0,a.optional)(Me),name:(0,a.pipe)((0,a.string)(),(0,a.minLength)(1)),pid:(0,a.optional)((0,a.pipe)((0,a.number)(),(0,a.integer)(),(0,a.minValue)(0))),port:C,shadowDatabasePort:C,version:(0,a.literal)("1")}),W=Symbol("initialize"),K="default",h=class{_databasePort;debug;dryRun;name;persistenceMode;pid;_port;_shadowDatabasePort;constructor(e){this._databasePort=e.databasePort??P,this.debug=e.debug??!1,this.dryRun=e.dryRun??!1,this.name=e.name??K,this.persistenceMode=e.persistenceMode,this.pid=e.pid??J.process.pid,this._port=e.port??P,this._shadowDatabasePort=e.shadowDatabasePort??P}static async createExclusively(e){let r=e?.dryRun!==!0&&e?.persistenceMode==="stateful"?new k(e):new H(e);return await r[W](),r}static async fromServerDump(e){let{debug:r,name:n=K}=e??{},s=v(n),o=k.getServerDumpPath(s),i=await re(o);if(i==null)return r&&console.debug(`[State] No server dump file found at: ${o}`),null;r&&(console.debug(`[State] server dump file found at "${o}":`),console.debug(i));let{issues:c,output:u,success:p}=(0,a.safeParse)((0,a.pipe)((0,a.string)(),(0,a.parseJson)(),Le),i);if(!p)throw r&&console.debug(`[State] Invalid server dump file at "${o}":
${JSON.stringify(c,null,2)}`),new Error(`Invalid Prisma Dev state for "${n}".`);return new k({databasePort:u.databasePort,debug:r,dryRun:!1,name:n,pid:u.pid,port:u.port,serverDump:u,shadowDatabasePort:u.shadowDatabasePort})}static async scan(e){let{debug:r,globs:n}=e??{},s=(0,g.join)(v(K),"..");r&&console.debug(`[State] scanning for server states in: ${s}`);let o=await oe(s,n);return r&&console.debug(`[State] found server names: ${JSON.stringify(o)}`),await Promise.all(o.map(i=>X(i,e)))}get databasePort(){return this._databasePort}get port(){return this._port}get shadowDatabasePort(){return this._shadowDatabasePort}},H=class extends h{constructor(e){super({...e,databasePort:e?.databasePort,persistenceMode:"stateless",port:e?.port,shadowDatabasePort:e?.shadowDatabasePort})}get databaseDumpPath(){return"<DUMP_PATH>"}get pgliteDataDirPath(){return"memory://"}async[W](){let e;try{e=await h.scan({debug:this.debug,onlyMetadata:!0})}catch(n){this.debug&&console.warn("[State] failed to scan for existing servers, assuming filesystem does not exist or other reasons.",n),e=[]}let r=await F({debug:this.debug,name:this.dryRun?this.name:"",requestedPorts:{databasePort:this.databasePort,port:this.port,shadowDatabasePort:this.shadowDatabasePort},servers:e});this._databasePort=r.databasePort,this._port=r.port,this._shadowDatabasePort=r.shadowDatabasePort}async close(){}async writeServerDump(){}},k=class t extends h{#t;#e;#s;#a;#n;#o;#r;constructor(e){super({...e,persistenceMode:"stateful"}),this.#o=!1,this.#e=v(this.name),this.#t=(0,g.join)(this.#e,"db_dump.bak"),this.#s=(0,g.join)(this.#e,".lock"),this.#a=(0,g.join)(this.#e,".pglite"),this.#r=e?.serverDump??null,this.#n=t.getServerDumpPath(this.#e)}static getServerDumpPath(e){return(0,g.join)(e,"server.json")}get databaseDumpPath(){return this.#t}get exports(){return this.#r?.exports}get pgliteDataDirPath(){return this.#a}async[W](){await se(this.#e),this.debug&&console.debug(`[State] using data directory: ${this.#e}`);try{await(0,w.lock)(this.#e,{lockfilePath:this.#s}),this.debug&&console.debug(`[State] obtained lock on: ${this.#e}`);let e=await h.scan({debug:this.debug,onlyMetadata:!0}),r=await F({debug:this.debug,name:this.name,requestedPorts:{databasePort:this.databasePort,port:this.port,shadowDatabasePort:this.shadowDatabasePort},servers:e});this._databasePort=r.databasePort,this._port=r.port,this._shadowDatabasePort=r.shadowDatabasePort,await this.writeServerDump()}catch(e){throw e instanceof Error&&"code"in e&&e.code==="ELOCKED"?new j(this):e}}async close(){if(!this.#o)try{await(0,w.unlock)(this.#e,{lockfilePath:this.#s}),this.#o=!0,this.debug&&console.debug(`[State] released lock on: ${this.#e}`)}catch(e){throw this.debug&&console.error(`[State] failed to release lock on: ${this.#e}`,e),e}}async writeServerDump(e){this.#r={name:this.name,version:"1",pid:J.process.pid,port:this.port,databasePort:this.databasePort,shadowDatabasePort:this.shadowDatabasePort,exports:e},await(0,he.writeFile)(this.#n,`${JSON.stringify(this.#r,null,2)}
`,{encoding:"utf-8"})}};async function Ie(t,e){await Pe(t,e);let r=v(typeof t=="string"?t:t.name);await ae(r)}async function X(t,e){let{debug:r,onlyMetadata:n}=e||{},s=typeof t=="string"?t:t.name,o=typeof t!="string"?t:void 0,i={databasePort:o?.databasePort??-1,exports:o?.exports,name:s,pid:o?.pid,port:o?.port??-1,shadowDatabasePort:o?.shadowDatabasePort??-1,version:"1"};try{let c=o||await h.fromServerDump({debug:r,name:s});if(!c)return r&&console.debug(`[State] no server state found for name: ${s}`),{...i,status:"no_such_server"};i.databasePort=c.databasePort,i.exports=c.exports,i.pid=c.pid,i.port=c.port,i.shadowDatabasePort=c.shadowDatabasePort;let{exports:u,pid:p}=c;if(n)return{...i,status:"unknown"};if(!U(p,r))return r&&console.debug(`[State] server state for "${s}" has no running process with PID: ${p}`),{...i,status:"not_running"};let f=v(s);try{if(!await(0,w.check)(f,{lockfilePath:(0,g.join)(f,".lock")}))return r&&console.debug(`[State] server state for "${s}" is not locked, indicating it is not running.`),{...i,status:"starting_up"}}catch(ge){r&&console.error(`[State] server state for "${s}" failed to check lock:`,ge)}if(!u)return{...i,status:"starting_up"};let{http:S}=u,{hc:be}=await import("hono/client"),M=await be(S.url).health.$get();if(!M.ok)return r&&console.debug(`[State] server state for "${s}" is not live: ${JSON.stringify(M)}`),{...i,status:"not_running"};let L=await M.json();return L.name!==t?(r&&console.debug(`[State] server state for "${s}" has mismatched health response: ${JSON.stringify(L)}`),{...i,status:"unknown"}):(r&&console.debug(`[State] server state for "${t}" is live: ${JSON.stringify(L)}`),{...i,status:"running"})}catch(c){return r&&console.error(`[State] failed to get server status for "${s}":`,c),{...i,status:"error"}}}function me(t){let{status:e}=t;return e==="running"||e==="starting_up"}async function Pe(t,e){let{pid:r,...n}=typeof t=="string"?await X(t,{debug:e}):t;if(!me(n))return!1;let s=await h.fromServerDump({debug:e,name:n.name});if(r==null){e&&console.debug(`[State] No PID found for server "${n.name}" to kill.`);try{await s?.close()}catch{}return!1}let o=await ie(r,e);try{await s?.close()}catch{}return o}var R=class extends Error{name="ServerStateAlreadyExistsError";constructor(e){super(`A Prisma Dev server with the name "${e}" is already running.`)}},j=class extends R{#t;name="ServerAlreadyRunningError";constructor(e){super(e.name),this.#t=e}get server(){return h.fromServerDump({debug:this.#t.debug,name:this.#t.name})}};0&&(module.exports={ServerAlreadyRunningError,ServerState,ServerStateAlreadyExistsError,deleteServer,getServerStatus,isServerRunning,killServer});
