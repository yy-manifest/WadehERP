import{d as f,e as w}from"./chunk-LMPFMHCB.js";import{b as c,f as O,g as V,h as N,i as T}from"./chunk-EPFUMVT3.js";import{writeFile as z}from"fs/promises";import{join as l}from"pathe";import{check as Q,lock as W,unlock as X}from"proper-lockfile";import{process as j}from"std-env";import{integer as C,literal as ee,minLength as te,minValue as F,number as q,object as P,optional as g,parseJson as re,pipe as h,safeParse as se,string as v,url as ae}from"valibot";import{setTimeout as Z}from"timers/promises";import{process as b}from"std-env";function y(r,e){if(r==null)return!1;try{return b.kill?.(r,0)??!0}catch(t){return e&&console.error(`Error checking if process with PID ${r} exists:`,t),!1}}async function A(r,e){if(!b.kill)return!1;try{b.kill(r,"SIGTERM")}catch(o){return e&&console.error(`Error killing process with PID ${r}:`,o),!1}let t=0;do{if(!y(r,e))return!0;await Z(100)}while(++t<50);try{return b.kill(r,"SIGKILL")}catch(o){return e&&console.error(`Error forcefully killing process with PID ${r}:`,o),!1}}var _=h(v(),ae()),L=P({connectionString:_,prismaORMConnectionString:g(_),terminalCommand:g(v())}),J=P({url:_}),x=h(q(),C(),F(1)),oe=P({database:L,http:J,ppg:J,shadowDatabase:L}),ne=P({databasePort:x,exports:g(oe),name:h(v(),te(1)),pid:g(h(q(),C(),F(0))),port:x,shadowDatabasePort:x,version:ee("1")}),E=Symbol("initialize"),k="default",u=class{_databasePort;debug;dryRun;name;persistenceMode;pid;_port;_shadowDatabasePort;constructor(e){this._databasePort=e.databasePort??f,this.debug=e.debug??!1,this.dryRun=e.dryRun??!1,this.name=e.name??k,this.persistenceMode=e.persistenceMode,this.pid=e.pid??j.pid,this._port=e.port??f,this._shadowDatabasePort=e.shadowDatabasePort??f}static async createExclusively(e){let t=e?.dryRun!==!0&&e?.persistenceMode==="stateful"?new p(e):new $(e);return await t[E](),t}static async fromServerDump(e){let{debug:t,name:o=k}=e??{},a=c(o),n=p.getServerDumpPath(a),s=await O(n);if(s==null)return t&&console.debug(`[State] No server dump file found at: ${n}`),null;t&&(console.debug(`[State] server dump file found at "${n}":`),console.debug(s));let{issues:i,output:d,success:m}=se(h(v(),re(),ne),s);if(!m)throw t&&console.debug(`[State] Invalid server dump file at "${n}":
${JSON.stringify(i,null,2)}`),new Error(`Invalid Prisma Dev state for "${o}".`);return new p({databasePort:d.databasePort,debug:t,dryRun:!1,name:o,pid:d.pid,port:d.port,serverDump:d,shadowDatabasePort:d.shadowDatabasePort})}static async scan(e){let{debug:t,globs:o}=e??{},a=l(c(k),"..");t&&console.debug(`[State] scanning for server states in: ${a}`);let n=await N(a,o);return t&&console.debug(`[State] found server names: ${JSON.stringify(n)}`),await Promise.all(n.map(s=>H(s,e)))}get databasePort(){return this._databasePort}get port(){return this._port}get shadowDatabasePort(){return this._shadowDatabasePort}},$=class extends u{constructor(e){super({...e,databasePort:e?.databasePort,persistenceMode:"stateless",port:e?.port,shadowDatabasePort:e?.shadowDatabasePort})}get databaseDumpPath(){return"<DUMP_PATH>"}get pgliteDataDirPath(){return"memory://"}async[E](){let e;try{e=await u.scan({debug:this.debug,onlyMetadata:!0})}catch(o){this.debug&&console.warn("[State] failed to scan for existing servers, assuming filesystem does not exist or other reasons.",o),e=[]}let t=await w({debug:this.debug,name:this.dryRun?this.name:"",requestedPorts:{databasePort:this.databasePort,port:this.port,shadowDatabasePort:this.shadowDatabasePort},servers:e});this._databasePort=t.databasePort,this._port=t.port,this._shadowDatabasePort=t.shadowDatabasePort}async close(){}async writeServerDump(){}},p=class r extends u{#t;#e;#s;#o;#n;#a;#r;constructor(e){super({...e,persistenceMode:"stateful"}),this.#a=!1,this.#e=c(this.name),this.#t=l(this.#e,"db_dump.bak"),this.#s=l(this.#e,".lock"),this.#o=l(this.#e,".pglite"),this.#r=e?.serverDump??null,this.#n=r.getServerDumpPath(this.#e)}static getServerDumpPath(e){return l(e,"server.json")}get databaseDumpPath(){return this.#t}get exports(){return this.#r?.exports}get pgliteDataDirPath(){return this.#o}async[E](){await V(this.#e),this.debug&&console.debug(`[State] using data directory: ${this.#e}`);try{await W(this.#e,{lockfilePath:this.#s}),this.debug&&console.debug(`[State] obtained lock on: ${this.#e}`);let e=await u.scan({debug:this.debug,onlyMetadata:!0}),t=await w({debug:this.debug,name:this.name,requestedPorts:{databasePort:this.databasePort,port:this.port,shadowDatabasePort:this.shadowDatabasePort},servers:e});this._databasePort=t.databasePort,this._port=t.port,this._shadowDatabasePort=t.shadowDatabasePort,await this.writeServerDump()}catch(e){throw e instanceof Error&&"code"in e&&e.code==="ELOCKED"?new I(this):e}}async close(){if(!this.#a)try{await X(this.#e,{lockfilePath:this.#s}),this.#a=!0,this.debug&&console.debug(`[State] released lock on: ${this.#e}`)}catch(e){throw this.debug&&console.error(`[State] failed to release lock on: ${this.#e}`,e),e}}async writeServerDump(e){this.#r={name:this.name,version:"1",pid:j.pid,port:this.port,databasePort:this.databasePort,shadowDatabasePort:this.shadowDatabasePort,exports:e},await z(this.#n,`${JSON.stringify(this.#r,null,2)}
`,{encoding:"utf-8"})}};async function De(r,e){await ue(r,e);let t=c(typeof r=="string"?r:r.name);await T(t)}async function H(r,e){let{debug:t,onlyMetadata:o}=e||{},a=typeof r=="string"?r:r.name,n=typeof r!="string"?r:void 0,s={databasePort:n?.databasePort??-1,exports:n?.exports,name:a,pid:n?.pid,port:n?.port??-1,shadowDatabasePort:n?.shadowDatabasePort??-1,version:"1"};try{let i=n||await u.fromServerDump({debug:t,name:a});if(!i)return t&&console.debug(`[State] no server state found for name: ${a}`),{...s,status:"no_such_server"};s.databasePort=i.databasePort,s.exports=i.exports,s.pid=i.pid,s.port=i.port,s.shadowDatabasePort=i.shadowDatabasePort;let{exports:d,pid:m}=i;if(o)return{...s,status:"unknown"};if(!y(m,t))return t&&console.debug(`[State] server state for "${a}" has no running process with PID: ${m}`),{...s,status:"not_running"};let R=c(a);try{if(!await Q(R,{lockfilePath:l(R,".lock")}))return t&&console.debug(`[State] server state for "${a}" is not locked, indicating it is not running.`),{...s,status:"starting_up"}}catch(G){t&&console.error(`[State] server state for "${a}" failed to check lock:`,G)}if(!d)return{...s,status:"starting_up"};let{http:K}=d,{hc:B}=await import("hono/client"),S=await B(K.url).health.$get();if(!S.ok)return t&&console.debug(`[State] server state for "${a}" is not live: ${JSON.stringify(S)}`),{...s,status:"not_running"};let D=await S.json();return D.name!==r?(t&&console.debug(`[State] server state for "${a}" has mismatched health response: ${JSON.stringify(D)}`),{...s,status:"unknown"}):(t&&console.debug(`[State] server state for "${r}" is live: ${JSON.stringify(D)}`),{...s,status:"running"})}catch(i){return t&&console.error(`[State] failed to get server status for "${a}":`,i),{...s,status:"error"}}}function ie(r){let{status:e}=r;return e==="running"||e==="starting_up"}async function ue(r,e){let{pid:t,...o}=typeof r=="string"?await H(r,{debug:e}):r;if(!ie(o))return!1;let a=await u.fromServerDump({debug:e,name:o.name});if(t==null){e&&console.debug(`[State] No PID found for server "${o.name}" to kill.`);try{await a?.close()}catch{}return!1}let n=await A(t,e);try{await a?.close()}catch{}return n}var M=class extends Error{name="ServerStateAlreadyExistsError";constructor(e){super(`A Prisma Dev server with the name "${e}" is already running.`)}},I=class extends M{#t;name="ServerAlreadyRunningError";constructor(e){super(e.name),this.#t=e}get server(){return u.fromServerDump({debug:this.#t.debug,name:this.#t.name})}};export{u as a,De as b,H as c,ie as d,ue as e,M as f,I as g};
